@isTest(SeeAllData=false)
private class DuplicateAccountBlockerTest
{
    @isTest
    private static void preventDuplicates_WithNullAccounts_ReturnsEmptySet()
    {
        // Given
        fflib_ApexMocks mocks = new fflib_ApexMocks();
        AccountsSelector mockSelector = (AccountsSelector)mocks.mock(AccountsSelector.class);
        AccountsSelector.instance = mockSelector;
        Utilities mockUtils = (Utilities)mocks.mock(Utilities.class);
        Utilities.instance = mockUtils;

        Set<Id> expected = new Set<Id>{};

        // When
        Set<Id> actual = DuplicateAccountBlocker.newInstance().preventDuplicates(null);

        // Then
        System.assertEquals(expected, actual);

        ((AccountsSelector)mocks.verify(mockSelector, mocks.never())).getForNames((Set<String>)fflib_Match.anyObject());
        ((Utilities)mocks.verify(mockUtils, mocks.never())).addError((SObject[])fflib_Match.anyObject(), fflib_Match.anyString());
    }
    
    @isTest
    private static void preventDuplicates_WithEmptyAccounts_ReturnsEmptySet()
    {
        // Given
        fflib_ApexMocks mocks = new fflib_ApexMocks();
        AccountsSelector mockSelector = (AccountsSelector)mocks.mock(AccountsSelector.class);
        AccountsSelector.instance = mockSelector;
        Utilities mockUtils = (Utilities)mocks.mock(Utilities.class);
        Utilities.instance = mockUtils;

        Account[] newRecords = new Account[]{};

        Set<Id> expected = new Set<Id>{};

        // When
        Set<Id> actual = DuplicateAccountBlocker.newInstance().preventDuplicates(new Map<Id, Account>(newRecords));

        // Then
        System.assertEquals(expected, actual);

        ((AccountsSelector)mocks.verify(mockSelector, mocks.never())).getForNames((Set<String>)fflib_Match.anyObject());
        ((Utilities)mocks.verify(mockUtils, mocks.never())).addError((SObject[])fflib_Match.anyObject(), fflib_Match.anyString());
    }
    
    @isTest
    private static void preventDuplicates_WithNoDuplicates_ReturnsEmptySet()
    {
        // Given
        fflib_ApexMocks mocks = new fflib_ApexMocks();
        AccountsSelector mockSelector = (AccountsSelector)mocks.mock(AccountsSelector.class);
        AccountsSelector.instance = mockSelector;
        Utilities mockUtils = (Utilities)mocks.mock(Utilities.class);
        Utilities.instance = mockUtils;

        Account[] newRecords = new Account[]{
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Unique'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Even more unique')
        };

        Account[] existingRecords = new Account[]{
            new Account(Id = newRecords[1].Id, Name = 'Unique'),
            new Account(Id = newRecords[0].Id, Name = 'Even more unique')
        };

        Set<String> accountNames = new Set<String>{
            'Unique',
            'Even more unique'
        };

        mocks.startStubbing();
        mocks.when(mockSelector.getForNames((Set<String>)fflib_Match.eq(accountNames))).thenReturn(existingRecords);
        mocks.stopStubbing();

        Set<Id> expected = new Set<Id>{};

        // When
        Set<Id> actual = DuplicateAccountBlocker.newInstance().preventDuplicates(new Map<Id, Account>(newRecords));

        // Then
        System.assertEquals(expected, actual);

        ((Utilities)mocks.verify(mockUtils, mocks.never())).addError((SObject[])fflib_Match.anyObject(), fflib_Match.anyString());
    }
    
    @isTest
    private static void preventDuplicates_SwappedAccountNames_ReturnsEmptySet()
    {
        // Given
        fflib_ApexMocks mocks = new fflib_ApexMocks();
        AccountsSelector mockSelector = (AccountsSelector)mocks.mock(AccountsSelector.class);
        AccountsSelector.instance = mockSelector;
        Utilities mockUtils = (Utilities)mocks.mock(Utilities.class);
        Utilities.instance = mockUtils;

        Account[] newRecords = new Account[]{
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Name swap 1'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Name swap 2')
        };

        Account[] existingRecords = new Account[]{
            new Account(Id = newRecords[1].Id, Name = 'Name swap 2'),
            new Account(Id = newRecords[0].Id, Name = 'Name swap 1')
        };

        Set<String> accountNames = new Set<String>{
            'Name swap 1',
            'Name swap 2'
        };

        mocks.startStubbing();
        mocks.when(mockSelector.getForNames((Set<String>)fflib_Match.eq(accountNames))).thenReturn(existingRecords);
        mocks.stopStubbing();

        Set<Id> expected = new Set<Id>{};

        // When
        Set<Id> actual = DuplicateAccountBlocker.newInstance().preventDuplicates(new Map<Id, Account>(newRecords));

        // Then
        System.assertEquals(expected, actual);

        ((Utilities)mocks.verify(mockUtils, mocks.never())).addError((SObject[])fflib_Match.anyObject(), fflib_Match.anyString());
    }
    
    @isTest
    private static void preventDuplicates_WithDuplicatesInNewSet_ReturnsDuplicateIds()
    {
        // Given
        fflib_ApexMocks mocks = new fflib_ApexMocks();
        AccountsSelector mockSelector = (AccountsSelector)mocks.mock(AccountsSelector.class);
        AccountsSelector.instance = mockSelector;
        Utilities mockUtils = (Utilities)mocks.mock(Utilities.class);
        Utilities.instance = mockUtils;

        Account[] newRecords = new Account[]{
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Duplicate in new set'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Duplicate in new set')
        };

        Account[] existingRecords = new Account[]{};

        Set<String> accountNames = new Set<String>{ 'Duplicate in new set' };

        mocks.startStubbing();
        mocks.when(mockSelector.getForNames((Set<String>)fflib_Match.eq(accountNames))).thenReturn(existingRecords);
        mocks.stopStubbing();

        Set<Id> expected = new Set<Id>{
            newRecords[0].Id,
            newRecords[1].Id
        };

        // When
        Set<Id> actual = DuplicateAccountBlocker.newInstance().preventDuplicates(new Map<Id, Account>(newRecords));

        // Then
        System.assertEquals(expected, actual);

        ((Utilities)mocks.verify(mockUtils)).addError(new Account[]{ newRecords[0] }, 'You cannot create an Account with the name "' + newRecords[0].Name + '", as this would create a duplicate');
        ((Utilities)mocks.verify(mockUtils)).addError(new Account[]{ newRecords[1] }, 'You cannot create an Account with the name "' + newRecords[1].Name + '", as this would create a duplicate');
    }

    @isTest
    private static void preventDuplicates_WithDuplicatesAgainstExistingSet_ReturnsDuplicateIds()
    {
        // Given
        fflib_ApexMocks mocks = new fflib_ApexMocks();
        AccountsSelector mockSelector = (AccountsSelector)mocks.mock(AccountsSelector.class);
        AccountsSelector.instance = mockSelector;
        Utilities mockUtils = (Utilities)mocks.mock(Utilities.class);
        Utilities.instance = mockUtils;

        Account[] newRecords = new Account[]{
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Duplicate on DB')
        };

        Account[] existingRecords = new Account[]{
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Duplicate on DB')
        };

        Set<String> accountNames = new Set<String>{ 'Duplicate on DB' };

        mocks.startStubbing();
        mocks.when(mockSelector.getForNames((Set<String>)fflib_Match.eq(accountNames))).thenReturn(existingRecords);
        mocks.stopStubbing();

        Set<Id> expected = new Set<Id>{ newRecords[0].Id };

        // When
        Set<Id> actual = DuplicateAccountBlocker.newInstance().preventDuplicates(new Map<Id, Account>(newRecords));

        // Then
        System.assertEquals(expected, actual);

        ((Utilities)mocks.verify(mockUtils)).addError(new Account[]{ newRecords[0] }, 'You cannot create an Account with the name "' + newRecords[0].Name + '", as this would create a duplicate');
    }
    
    @isTest
    private static void preventDuplicates_WithMixOfDuplicatedAndNot_ReturnsDuplicateIds()
    {
        // Given
        fflib_ApexMocks mocks = new fflib_ApexMocks();
        AccountsSelector mockSelector = (AccountsSelector)mocks.mock(AccountsSelector.class);
        AccountsSelector.instance = mockSelector;
        Utilities mockUtils = (Utilities)mocks.mock(Utilities.class);
        Utilities.instance = mockUtils;

        Account[] newRecords = new Account[]{
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Unique'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Unique on DB'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Duplicate in new set'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Duplicate in new set'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Duplicate on DB'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Name swap 1'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Name swap 2')
        };

        Account[] existingRecords = new Account[]{
            new Account(Id = newRecords[1].Id, Name = 'Unique on DB'),
            new Account(Id = fflib_IDGenerator.generate(Account.SObjectType), Name = 'Duplicate on DB'),
            new Account(Id = newRecords[5].Id, Name = 'Name swap 2'),
            new Account(Id = newRecords[6].Id, Name = 'Name swap 1')
        };

        Set<String> accountNames = new Set<String>{
            'Unique',
            'Unique on DB',
            'Duplicate in new set',
            'Duplicate in new set',
            'Duplicate on DB',
            'Name swap 1',
            'Name swap 2'
        };

        mocks.startStubbing();
        mocks.when(mockSelector.getForNames((Set<String>)fflib_Match.eq(accountNames))).thenReturn(existingRecords);
        mocks.stopStubbing();

        Set<Id> expected = new Set<Id>{
            newRecords[2].Id,
            newRecords[3].Id,
            newRecords[4].Id
        };

        // When
        Set<Id> actual = DuplicateAccountBlocker.newInstance().preventDuplicates(new Map<Id, Account>(newRecords));

        // Then
        System.assertEquals(expected, actual);

        ((Utilities)mocks.verify(mockUtils)).addError(new Account[]{ newRecords[2] }, 'You cannot create an Account with the name "' + newRecords[2].Name + '", as this would create a duplicate');
        ((Utilities)mocks.verify(mockUtils)).addError(new Account[]{ newRecords[3] }, 'You cannot create an Account with the name "' + newRecords[3].Name + '", as this would create a duplicate');
        ((Utilities)mocks.verify(mockUtils)).addError(new Account[]{ newRecords[4] }, 'You cannot create an Account with the name "' + newRecords[4].Name + '", as this would create a duplicate');
    }
}